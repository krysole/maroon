// Generated by meta.
"use strict";

const FAIL = Symbol("FAIL");

module.exports =
class Parser {
  
  match(rule, input, name) {
    this.$input    = input;
    this.$name     = (name != null ? name : "unnamed");
    this.$position = 0;
    this.$furthest = 0;
    this.$memotab  = [];
    
    for (let i = 0, c = this.$input.length + 1; i < c; i++) {
      this.$memotab[i] = { rule: null, result: null, position: -1 }
    }
    
    let result = this[rule]();
    if (result !== FAIL) {
      return result;
    }
    else {
      throw new Error(`Failed to match, furthest position ${this.linecol(this.$furthest)}.`);
    }
  }
  
  log(message) {
    console.log(`${this.constructor.name}.prototype.log() ${this.linecol()} ${message}`);
  }
  
  linecol(position) {
    if (position == null) position = this.$position;
    
    let line   = 1;
    let column = 1;
    
    for (let i = 0; i < position; i++) {
      if (this.$input[i] === "\r") {
        if (this.$input[i + 1] === "\n") i++;
        line++;
        column = 1;
      }
      else if (this.$input[i] === "\n") {
        if (this.$input[i + 1] === "\r") i++;
        line++;
        column = 1;
      }
      else {
        column++;
      }
    }
    
    return {
      name: this.$name,
      line: line,
      column: column,
      toString() { return `${this.name}:${this.line}:${this.column}`; },
    };
  }
  
  char(charset) {
    if (this.$position >= this.$input.length) return FAIL;
    
    let c = this.$input[this.$position];
    if (charset != null && !charset.includes(c)) return FAIL;
    
    this.$position += 1;
    if (this.$position > this.$furthest) this.$furthest = this.$position;
    
    return c;
  }
  
  range(start, end) {
    if (this.$position >= this.$input.length) return FAIL;
    
    let c = this.$input[this.$position];
    if (c < start || c > end) return FAIL;
    
    this.$position += 1;
    if (this.$position > this.$furthest) this.$furthest = this.$position;
    
    return c;
  }
  
  string(string) {
    if (this.$input.slice(this.$position, this.$position + string.length) === string) {
      this.$position += string.length;
      if (this.$position > this.$furthest) this.$furthest = this.$position;
      
      return string;
    }
    else {
      return FAIL;
    }
  }
  
  nothing() {
    return null;
  }
  
  
  pos() {
    return this.$position;
  }
  
  slice(start, end) {
    return this.$input.slice(start, end);
  }
  
  unit() {
    let RESULT = FAIL;
    let ds;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "unit") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.declaration();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      ds = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.end();
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "Source", declarations: ds };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "unit";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  declaration() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "declaration") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      RESULT = this.structDeclaration();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.letDeclaration();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.functionDeclaration();
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "declaration";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  structDeclaration() {
    let RESULT = FAIL;
    let n, fs;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "structDeclaration") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("struct");
      if (RESULT === FAIL) break;
      
      RESULT = this.local();
      n = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p("{");
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.structField();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      fs = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p("}");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "StructDeclaration", name: n, fields: fs };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "structDeclaration";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  structField() {
    let RESULT = FAIL;
    let n, t;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "structField") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id();
      n = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(":");
      if (RESULT === FAIL) break;
      
      RESULT = this.type();
      t = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "Field", name: n, type: t };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "structField";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  letDeclaration() {
    let RESULT = FAIL;
    let vs;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "letDeclaration") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("let");
      if (RESULT === FAIL) break;
      
      while (true) { // DELIMITED
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          if (ARRAY.length > 0) {
            RESULT = this.p(",");
            if (RESULT === FAIL) {
              this.$position = INITPOS;
              break;
            }
          }
          
          RESULT = this.variable();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        if (ARRAY.length >= 1) RESULT = ARRAY;
        else                   RESULT = FAIL;
        break;
      }
      vs = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "LetDeclaration", variables: vs };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "letDeclaration";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  functionDeclaration() {
    let RESULT = FAIL;
    let n, ps, r, ss;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "functionDeclaration") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.id("fn");
        if (RESULT === FAIL) break;
        
        RESULT = this.local();
        n = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p("(");
        if (RESULT === FAIL) break;
        
        while (true) { // DELIMITED
          let ARRAY = [];
          
          while (true) {
            let INITPOS = this.$position;
            
            if (ARRAY.length > 0) {
              RESULT = this.p(",");
              if (RESULT === FAIL) {
                this.$position = INITPOS;
                break;
              }
            }
            
            RESULT = this.parameter();
            if (RESULT === FAIL) {
              this.$position = INITPOS;
              break;
            }
            
            ARRAY.push(RESULT);
          }
          
          RESULT = ARRAY;
          break;
        }
        ps = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p(")");
        if (RESULT === FAIL) break;
        
        RESULT = this.p(":");
        if (RESULT === FAIL) break;
        
        RESULT = this.type();
        r = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p("{");
        if (RESULT === FAIL) break;
        
        while (true) { // REPEAT
          let ARRAY = [];
          
          while (true) {
            let INITPOS = this.$position;
            
            RESULT = this.statement();
            if (RESULT === FAIL) {
              this.$position = INITPOS;
              break;
            }
            
            ARRAY.push(RESULT);
          }
          
          RESULT = ARRAY;
          break;
        }
        ss = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p("}");
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "FunctionDeclaration", name: n, parameters: ps, return: r, statements: ss };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.id("fn");
        if (RESULT === FAIL) break;
        
        RESULT = this.local();
        n = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p("(");
        if (RESULT === FAIL) break;
        
        while (true) { // DELIMITED
          let ARRAY = [];
          
          while (true) {
            let INITPOS = this.$position;
            
            if (ARRAY.length > 0) {
              RESULT = this.p(",");
              if (RESULT === FAIL) {
                this.$position = INITPOS;
                break;
              }
            }
            
            RESULT = this.parameter();
            if (RESULT === FAIL) {
              this.$position = INITPOS;
              break;
            }
            
            ARRAY.push(RESULT);
          }
          
          RESULT = ARRAY;
          break;
        }
        ps = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p(")");
        if (RESULT === FAIL) break;
        
        RESULT = this.p(":");
        if (RESULT === FAIL) break;
        
        RESULT = this.type();
        r = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p(";");
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "FunctionDeclaration", name: n, parameters: ps, return: r, statements: null };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "functionDeclaration";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  statement() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "statement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      RESULT = this.labelStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.letStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.ifStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.unlessStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.onceStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.foreverStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.whileStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.untilStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.doWhileStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.doUntilStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.breakStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.continueStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.returnStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.gotoStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.expressionStatement();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.emptyStatement();
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "statement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  labelStatement() {
    let RESULT = FAIL;
    let n;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "labelStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("label");
      if (RESULT === FAIL) break;
      
      RESULT = this.id();
      n = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "LabelStatement", name: n };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "labelStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  letStatement() {
    let RESULT = FAIL;
    let vs;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "letStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("let");
      if (RESULT === FAIL) break;
      
      while (true) { // DELIMITED
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          if (ARRAY.length > 0) {
            RESULT = this.p(",");
            if (RESULT === FAIL) {
              this.$position = INITPOS;
              break;
            }
          }
          
          RESULT = this.variable();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        if (ARRAY.length >= 1) RESULT = ARRAY;
        else                   RESULT = FAIL;
        break;
      }
      vs = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "LetStatement", variables: vs };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "letStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  ifStatement() {
    let RESULT = FAIL;
    let c, t, f;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "ifStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("if");
      if (RESULT === FAIL) break;
      
      RESULT = this.expression();
      c = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // CHOICE
        let INITPOS = this.$position;
        
        this.$position = INITPOS;
        while (true) { // SEQUENCE
          RESULT = this.id("then");
          if (RESULT === FAIL) break;
          
          RESULT = this.statement();
          t = RESULT;
          if (RESULT === FAIL) break;
          
          break;
        }
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.block();
        t = RESULT;
        if (RESULT !== FAIL) break;
        
        break;
      }
      if (RESULT === FAIL) break;
      
      while (true) { // OPTIONAL
        let INITPOS = this.$position;
        
        while (true) { // CHOICE
          let INITPOS = this.$position;
          
          this.$position = INITPOS;
          while (true) { // SEQUENCE
            RESULT = this.id("else");
            if (RESULT === FAIL) break;
            
            while (true) { // NEGATE
              let INITPOS = this.$position;
              
              RESULT = this.p("{");
              if (RESULT === FAIL) {
                this.$position = INITPOS;
                
                RESULT = null;
                break;
              }
              else {
                RESULT = FAIL;
                break;
              }
            }
            if (RESULT === FAIL) break;
            
            RESULT = this.statement();
            f = RESULT;
            if (RESULT === FAIL) break;
            
            break;
          }
          if (RESULT !== FAIL) break;
          
          this.$position = INITPOS;
          RESULT = this.block();
          f = RESULT;
          if (RESULT !== FAIL) break;
          
          break;
        }
        if (RESULT === FAIL) {
          this.$position = INITPOS;
          
          RESULT = null;
        }
        
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "IfStatement", negated: false, condition: c, consiquent: t, alternative: f };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "ifStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  unlessStatement() {
    let RESULT = FAIL;
    let c, t, f;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "unlessStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("unless");
      if (RESULT === FAIL) break;
      
      RESULT = this.expression();
      c = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // CHOICE
        let INITPOS = this.$position;
        
        this.$position = INITPOS;
        while (true) { // SEQUENCE
          RESULT = this.id("then");
          if (RESULT === FAIL) break;
          
          RESULT = this.statement();
          t = RESULT;
          if (RESULT === FAIL) break;
          
          break;
        }
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.block();
        t = RESULT;
        if (RESULT !== FAIL) break;
        
        break;
      }
      if (RESULT === FAIL) break;
      
      while (true) { // OPTIONAL
        let INITPOS = this.$position;
        
        while (true) { // CHOICE
          let INITPOS = this.$position;
          
          this.$position = INITPOS;
          while (true) { // SEQUENCE
            RESULT = this.id("else");
            if (RESULT === FAIL) break;
            
            while (true) { // NEGATE
              let INITPOS = this.$position;
              
              RESULT = this.p("{");
              if (RESULT === FAIL) {
                this.$position = INITPOS;
                
                RESULT = null;
                break;
              }
              else {
                RESULT = FAIL;
                break;
              }
            }
            if (RESULT === FAIL) break;
            
            RESULT = this.statement();
            f = RESULT;
            if (RESULT === FAIL) break;
            
            break;
          }
          if (RESULT !== FAIL) break;
          
          this.$position = INITPOS;
          RESULT = this.block();
          f = RESULT;
          if (RESULT !== FAIL) break;
          
          break;
        }
        if (RESULT === FAIL) {
          this.$position = INITPOS;
          
          RESULT = null;
        }
        
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "IfStatement", negated: true, condition: c, consiquent: t, alternative: f };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "unlessStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  onceStatement() {
    let RESULT = FAIL;
    let b;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "onceStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("once");
      if (RESULT === FAIL) break;
      
      RESULT = this.block();
      b = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "OnceStatement", body: b };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "onceStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  foreverStatement() {
    let RESULT = FAIL;
    let b;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "foreverStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("forever");
      if (RESULT === FAIL) break;
      
      RESULT = this.block();
      b = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "ForeverStatement", body: b};
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "foreverStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  whileStatement() {
    let RESULT = FAIL;
    let c, b;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "whileStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("while");
      if (RESULT === FAIL) break;
      
      RESULT = this.condition();
      c = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // CHOICE
        let INITPOS = this.$position;
        
        this.$position = INITPOS;
        while (true) { // SEQUENCE
          RESULT = this.id("do");
          if (RESULT === FAIL) break;
          
          RESULT = this.statement();
          b = RESULT;
          if (RESULT === FAIL) break;
          
          break;
        }
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.block();
        b = RESULT;
        if (RESULT !== FAIL) break;
        
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "WhileStatement", negated: false, condition: c, body: b };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "whileStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  untilStatement() {
    let RESULT = FAIL;
    let c, b;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "untilStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("until");
      if (RESULT === FAIL) break;
      
      RESULT = this.condition();
      c = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // CHOICE
        let INITPOS = this.$position;
        
        this.$position = INITPOS;
        while (true) { // SEQUENCE
          RESULT = this.id("do");
          if (RESULT === FAIL) break;
          
          RESULT = this.statement();
          b = RESULT;
          if (RESULT === FAIL) break;
          
          break;
        }
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.block();
        b = RESULT;
        if (RESULT !== FAIL) break;
        
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "WhileStatement", negated: true, condition: c, body: b };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "untilStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  doWhileStatement() {
    let RESULT = FAIL;
    let b, c;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "doWhileStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("do");
      if (RESULT === FAIL) break;
      
      while (true) { // CHOICE
        let INITPOS = this.$position;
        
        this.$position = INITPOS;
        while (true) { // SEQUENCE
          while (true) { // NEGATE
            let INITPOS = this.$position;
            
            RESULT = this.p("{");
            if (RESULT === FAIL) {
              this.$position = INITPOS;
              
              RESULT = null;
              break;
            }
            else {
              RESULT = FAIL;
              break;
            }
          }
          if (RESULT === FAIL) break;
          
          RESULT = this.statement();
          b = RESULT;
          if (RESULT === FAIL) break;
          
          break;
        }
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.block();
        b = RESULT;
        if (RESULT !== FAIL) break;
        
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.id("while");
      if (RESULT === FAIL) break;
      
      RESULT = this.expression();
      c = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "DoWhileStatement", negated: false, condition: c, body: b };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "doWhileStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  doUntilStatement() {
    let RESULT = FAIL;
    let b, c;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "doUntilStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("do");
      if (RESULT === FAIL) break;
      
      while (true) { // CHOICE
        let INITPOS = this.$position;
        
        this.$position = INITPOS;
        while (true) { // SEQUENCE
          while (true) { // NEGATE
            let INITPOS = this.$position;
            
            RESULT = this.p("{");
            if (RESULT === FAIL) {
              this.$position = INITPOS;
              
              RESULT = null;
              break;
            }
            else {
              RESULT = FAIL;
              break;
            }
          }
          if (RESULT === FAIL) break;
          
          RESULT = this.statement();
          b = RESULT;
          if (RESULT === FAIL) break;
          
          break;
        }
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.block();
        b = RESULT;
        if (RESULT !== FAIL) break;
        
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.id("until");
      if (RESULT === FAIL) break;
      
      RESULT = this.expression();
      c = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "DoWhileStatement", negated: true, condition: c, body: b };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "doUntilStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  breakStatement() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "breakStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("break");
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "BreakStatement" };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "breakStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  continueStatement() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "continueStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("continue");
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "ContinueStatement" };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "continueStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  returnStatement() {
    let RESULT = FAIL;
    let e;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "returnStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("return");
      if (RESULT === FAIL) break;
      
      while (true) { // OPTIONAL
        let INITPOS = this.$position;
        
        RESULT = this.expression();
        if (RESULT === FAIL) {
          this.$position = INITPOS;
          
          RESULT = null;
        }
        
        break;
      }
      e = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "ReturnStatement", expression: e };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "returnStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  gotoStatement() {
    let RESULT = FAIL;
    let n;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "gotoStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id("goto");
      if (RESULT === FAIL) break;
      
      RESULT = this.id();
      n = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "GotoStatement", name: n };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "gotoStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  expressionStatement() {
    let RESULT = FAIL;
    let e;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "expressionStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.expression();
      e = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "ExpressionStatement", expression: e };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "expressionStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  emptyStatement() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "emptyStatement") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.p(";");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "EmptyStatement" };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "emptyStatement";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  block() {
    let RESULT = FAIL;
    let ss;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "block") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.p("{");
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.statement();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      ss = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p("}");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "Block", statements: ss };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "block";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  expression() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "expression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    RESULT = this.logicalInfixExpression();
    
    MEMO.rule = "expression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  logicalInfixExpression() {
    let RESULT = FAIL;
    let a, b;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "logicalInfixExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.logicalNotExpression();
      a = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.id("or");
              if (RESULT === FAIL) break;
              
              RESULT = this.logicalNotExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "LogicalOrExpression",  a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.id("xor");
              if (RESULT === FAIL) break;
              
              RESULT = this.logicalNotExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "LogicalXorExpression", a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.id("and");
              if (RESULT === FAIL) break;
              
              RESULT = this.logicalNotExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "LogicalAndExpression", a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = a;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "logicalInfixExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  logicalNotExpression() {
    let RESULT = FAIL;
    let a;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "logicalNotExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.id("not");
        if (RESULT === FAIL) break;
        
        RESULT = this.logicalNotExpression();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "LogicalNotExpression", a: a };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.assignmentExpression();
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "logicalNotExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  assignmentExpression() {
    let RESULT = FAIL;
    let l, e;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "assignmentExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.vectorInfixExpression();
        l = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p("=");
        if (RESULT === FAIL) break;
        
        RESULT = this.expression();
        e = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "AssignmentExpression", location: l, expression: e };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.vectorInfixExpression();
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "assignmentExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  vectorInfixExpression() {
    let RESULT = FAIL;
    let a, b;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "vectorInfixExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.addExpression();
      a = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("|");
              if (RESULT === FAIL) break;
              
              RESULT = this.addExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "InfixExpression", o: "|", a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("^");
              if (RESULT === FAIL) break;
              
              RESULT = this.addExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "InfixExpression", o: "^", a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("&");
              if (RESULT === FAIL) break;
              
              RESULT = this.addExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "InfixExpression", o: "&", a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = a;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "vectorInfixExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  addExpression() {
    let RESULT = FAIL;
    let a, b;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "addExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.mulExpression();
      a = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("+");
              if (RESULT === FAIL) break;
              
              RESULT = this.mulExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "InfixExpression", o: "+", a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("-");
              if (RESULT === FAIL) break;
              
              RESULT = this.mulExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "InfixExpression", o: "-", a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = a;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "addExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  mulExpression() {
    let RESULT = FAIL;
    let a, b;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "mulExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.expExpression();
      a = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("*");
              if (RESULT === FAIL) break;
              
              RESULT = this.expExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "InfixExpression", o: "*",    a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("/");
              if (RESULT === FAIL) break;
              
              RESULT = this.expExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "InfixExpression", o: "/",    a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.id("quot");
              if (RESULT === FAIL) break;
              
              RESULT = this.expExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "InfixExpression", o: "quot", a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.id("rem");
              if (RESULT === FAIL) break;
              
              RESULT = this.expExpression();
              b = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "InfixExpression", o: "rem",  a: a, b: b };
              a = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = a;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "mulExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  expExpression() {
    let RESULT = FAIL;
    let a, b;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "expExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.prefixExpression();
      a = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // SEQUENCE
            RESULT = this.p("exp");
            if (RESULT === FAIL) break;
            
            RESULT = this.prefixExpression();
            b = RESULT;
            if (RESULT === FAIL) break;
            
            RESULT = { tag: "InfixExpression", o: "exp", a: a, b: b };
            a = RESULT;
            if (RESULT === FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = a;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "expExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  prefixExpression() {
    let RESULT = FAIL;
    let a;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "prefixExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.p("+");
        if (RESULT === FAIL) break;
        
        RESULT = this.secondaryExpression();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "PrefixExpression", o: "+", a: a };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.p("-");
        if (RESULT === FAIL) break;
        
        RESULT = this.secondaryExpression();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "PrefixExpression", o: "-", a: a };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.p("~");
        if (RESULT === FAIL) break;
        
        RESULT = this.secondaryExpression();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "PrefixExpression", o: "~", a: a };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.secondaryExpression();
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "prefixExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  secondaryExpression() {
    let RESULT = FAIL;
    let e, n, as, a;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "secondaryExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.log("secondaryExpression start");
      if (RESULT === FAIL) break;
      
      RESULT = this.primaryExpression();
      e = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.log("secondaryExpression after primaryExpression");
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p(".");
              if (RESULT === FAIL) break;
              
              RESULT = this.id();
              n = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "FieldExpression",     subject: e, name: n };
              e = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("(");
              if (RESULT === FAIL) break;
              
              while (true) { // DELIMITED
                let ARRAY = [];
                
                while (true) {
                  let INITPOS = this.$position;
                  
                  if (ARRAY.length > 0) {
                    RESULT = this.p(",");
                    if (RESULT === FAIL) {
                      this.$position = INITPOS;
                      break;
                    }
                  }
                  
                  RESULT = this.expression();
                  if (RESULT === FAIL) {
                    this.$position = INITPOS;
                    break;
                  }
                  
                  ARRAY.push(RESULT);
                }
                
                RESULT = ARRAY;
                break;
              }
              as = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = this.p(")");
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "CallExpression",      subject: e, arguments: as };
              e = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("[");
              if (RESULT === FAIL) break;
              
              RESULT = this.expression();
              a = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = this.p("]");
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "SubscriptExpression", subject: e, argument: a };
              e = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = e;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "secondaryExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  primaryExpression() {
    let RESULT = FAIL;
    let a, n;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "primaryExpression") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.p("[");
        if (RESULT === FAIL) break;
        
        RESULT = this.expression();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p("]");
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "DereferenceExpression", subject: a };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.p("(");
        if (RESULT === FAIL) break;
        
        RESULT = this.expression();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p(")");
        if (RESULT === FAIL) break;
        
        RESULT = a;
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.log("primaryExpression start");
        if (RESULT === FAIL) break;
        
        RESULT = this.local();
        n = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.log("primaryExpression after local");
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "LookupExpression", name: n };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.binintLiteral();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.octintLiteral();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.decintLiteral();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.hexintLiteral();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.stringLiteral();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.id("true");
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "BooleanLiteral", value: true };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.id("false");
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "BooleanLiteral", value: false };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.id("null");
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "NullLiteral" };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "primaryExpression";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  type() {
    let RESULT = FAIL;
    let t, a;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "type") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.primaryType();
      t = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("[");
              if (RESULT === FAIL) break;
              
              RESULT = this.p("]");
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "ArrayType", type: t, count: null };
              t = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              RESULT = this.p("[");
              if (RESULT === FAIL) break;
              
              RESULT = this.expression();
              a = RESULT;
              if (RESULT === FAIL) break;
              
              RESULT = this.p("]");
              if (RESULT === FAIL) break;
              
              RESULT = { tag: "ArrayType", type: t, count: a };
              t = RESULT;
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = t;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "type";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  primaryType() {
    let RESULT = FAIL;
    let ps, r, t, n;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "primaryType") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.p("[");
        if (RESULT === FAIL) break;
        
        RESULT = this.id("fn");
        if (RESULT === FAIL) break;
        
        RESULT = this.p("(");
        if (RESULT === FAIL) break;
        
        while (true) { // DELIMITED
          let ARRAY = [];
          
          while (true) {
            let INITPOS = this.$position;
            
            if (ARRAY.length > 0) {
              RESULT = this.p(",");
              if (RESULT === FAIL) {
                this.$position = INITPOS;
                break;
              }
            }
            
            RESULT = this.parameter();
            if (RESULT === FAIL) {
              this.$position = INITPOS;
              break;
            }
            
            ARRAY.push(RESULT);
          }
          
          RESULT = ARRAY;
          break;
        }
        ps = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p(")");
        if (RESULT === FAIL) break;
        
        RESULT = this.p(":");
        if (RESULT === FAIL) break;
        
        RESULT = this.type();
        r = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p("]");
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "FunctionType", parameters: ps, return: r };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.p("[");
        if (RESULT === FAIL) break;
        
        RESULT = this.type();
        t = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.p("]");
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "PointerType", type: t };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.local();
        n = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = { tag: "LookupType", name: n };
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "primaryType";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  variable() {
    let RESULT = FAIL;
    let n, e;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "variable") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.local();
      n = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p("=");
      if (RESULT === FAIL) break;
      
      RESULT = this.expression();
      e = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "Variable", name: n, expression: e };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "variable";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  parameter() {
    let RESULT = FAIL;
    let n, t;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "parameter") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.local();
      n = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.p(":");
      if (RESULT === FAIL) break;
      
      RESULT = this.type();
      t = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "Parameter", name: n, type: t };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "parameter";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  binintLiteral() {
    let RESULT = FAIL;
    let ds, v;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "binintLiteral") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.ws();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.char("0");
      if (RESULT === FAIL) break;
      
      RESULT = this.char("b");
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT1
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            RESULT = this.bin();
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            RESULT = this.char("_");
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        if (ARRAY.length === 0) RESULT = FAIL;
        else                    RESULT = ARRAY;
        break;
      }
      ds = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = (new BigNumber(ds.join("").replace(/_/g, ""), 2));
      v = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "IntegerLiteral", signed: null, width: null, value: v };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "binintLiteral";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  octintLiteral() {
    let RESULT = FAIL;
    let ds, v;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "octintLiteral") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.ws();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.char("0");
      if (RESULT === FAIL) break;
      
      RESULT = this.char("o");
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT1
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            RESULT = this.oct();
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            RESULT = this.char("_");
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        if (ARRAY.length === 0) RESULT = FAIL;
        else                    RESULT = ARRAY;
        break;
      }
      ds = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = (new BigNumber(ds.join("").replace(/_/g, ""), 8));
      v = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "IntegerLiteral", signed: null, width: null, value: v };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "octintLiteral";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  decintLiteral() {
    let RESULT = FAIL;
    let d, ds, v;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "decintLiteral") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.ws();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.dec();
      d = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            RESULT = this.dec();
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            RESULT = this.char("_");
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      ds = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = (new BigNumber((d + ds.join("")).replace(/_/g, ""), 8));
      v = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "IntegerLiteral", signed: null, width: null, value: v };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "decintLiteral";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  hexintLiteral() {
    let RESULT = FAIL;
    let ds, v;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "hexintLiteral") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.ws();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.char("0");
      if (RESULT === FAIL) break;
      
      RESULT = this.char("x");
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT1
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            RESULT = this.hex();
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            RESULT = this.char("_");
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        if (ARRAY.length === 0) RESULT = FAIL;
        else                    RESULT = ARRAY;
        break;
      }
      ds = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = (new BigNumber(ds.join("").replace(/_/g, ""), 16));
      v = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "IntegerLiteral", signed: null, width: null, value: v };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "hexintLiteral";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  stringLiteral() {
    let RESULT = FAIL;
    let cs;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "stringLiteral") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.ws();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.char("\"");
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              while (true) { // NEGATE
                let INITPOS = this.$position;
                
                RESULT = this.char("\\\"\r\n");
                if (RESULT === FAIL) {
                  this.$position = INITPOS;
                  
                  RESULT = null;
                  break;
                }
                else {
                  RESULT = FAIL;
                  break;
                }
              }
              if (RESULT === FAIL) break;
              
              RESULT = this.char();
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            RESULT = this.stringEscapeCharacter();
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      cs = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = this.char("\"");
      if (RESULT === FAIL) break;
      
      RESULT = { tag: "StringLiteral", value: cs.join("") };
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "stringLiteral";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  stringEscapeCharacter() {
    let RESULT = FAIL;
    let a, b, c, d, e, f;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "stringEscapeCharacter") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\a");
        if (RESULT === FAIL) break;
        
        RESULT = "\x07";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\b");
        if (RESULT === FAIL) break;
        
        RESULT = "\x08";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\f");
        if (RESULT === FAIL) break;
        
        RESULT = "\x0C";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\n");
        if (RESULT === FAIL) break;
        
        RESULT = "\x0A";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\r");
        if (RESULT === FAIL) break;
        
        RESULT = "\x0D";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\t");
        if (RESULT === FAIL) break;
        
        RESULT = "\x09";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\v");
        if (RESULT === FAIL) break;
        
        RESULT = "\x0B";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\\\");
        if (RESULT === FAIL) break;
        
        RESULT = "\x5C";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\\'");
        if (RESULT === FAIL) break;
        
        RESULT = "\x27";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\\"");
        if (RESULT === FAIL) break;
        
        RESULT = "\x22";
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\x");
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        b = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = String.fromCharCode(parseInt(a + b, 16));
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\u");
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        b = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        c = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        d = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = String.fromCharCode(parseInt(a + b + c + d, 16));
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\U");
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        b = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        c = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        d = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        e = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        f = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = String.fromCharCode(parseInt(a + b + c + d + e + f, 16));
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.string("\\U+");
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        a = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        b = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        c = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        d = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        e = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = this.hex();
        f = RESULT;
        if (RESULT === FAIL) break;
        
        RESULT = String.fromCharCode(parseInt(a + b + c + d + e + f, 16));
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "stringEscapeCharacter";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  local() {
    let RESULT = FAIL;
    let n;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "local") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.id();
      n = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = ([
        "fn", "struct", 
        "label", "let",
        "if", "unless",
        "once", "forever", 
        "while", "until", "repeat",
        "break", "continue", 
        "return", 
        "goto",
        "and", "xor", "or", "not",
        "quot", "rem"
      ].excludes(n) ? null : FAIL);
      if (RESULT === FAIL) break;
      
      RESULT = n;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "local";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  id(expected) {
    let RESULT = FAIL;
    let c, cs, i;
    
    while (true) { // SEQUENCE
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.ws();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.initIdChar();
      c = RESULT;
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.restIdChar();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      cs = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = (c + cs.join(""));
      i = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = (((expected != null && expected === i) || (expected == null)) ? null : FAIL);
      if (RESULT === FAIL) break;
      
      RESULT = i;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    return RESULT;
  }
  
  p(expected) {
    let RESULT = FAIL;
    let s;
    
    while (true) { // SEQUENCE
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.ws();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      while (true) { // CHOICE
        let INITPOS = this.$position;
        
        this.$position = INITPOS;
        RESULT = this.char("([{}])");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string(".");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string(":");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("?");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string(",");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string(";");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("==");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("/=");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string(">=");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("<=");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("<");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string(">");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("+");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("-");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("*");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("/");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("|");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("^");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("&");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("~");
        if (RESULT !== FAIL) break;
        
        this.$position = INITPOS;
        RESULT = this.string("=");
        if (RESULT !== FAIL) break;
        
        break;
      }
      s = RESULT;
      if (RESULT === FAIL) break;
      
      RESULT = ((expected === s) ? null : FAIL);
      if (RESULT === FAIL) break;
      
      RESULT = s;
      if (RESULT === FAIL) break;
      
      break;
    }
    
    return RESULT;
  }
  
  end() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "end") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          RESULT = this.ws();
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      while (true) { // NEGATE
        let INITPOS = this.$position;
        
        RESULT = this.char();
        if (RESULT === FAIL) {
          this.$position = INITPOS;
          
          RESULT = null;
          break;
        }
        else {
          RESULT = FAIL;
          break;
        }
      }
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "end";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  initIdChar() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "initIdChar") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      RESULT = this.range("A", "Z");
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.range("a", "z");
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.char("_");
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "initIdChar";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  restIdChar() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "restIdChar") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      RESULT = this.range("A", "Z");
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.range("a", "z");
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.char("_");
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.range("0", "9");
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "restIdChar";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  bin() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "bin") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    RESULT = this.range("0", "1");
    
    MEMO.rule = "bin";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  oct() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "oct") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    RESULT = this.range("0", "7");
    
    MEMO.rule = "oct";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  dec() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "dec") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    RESULT = this.range("0", "9");
    
    MEMO.rule = "dec";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  hex() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "hex") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      RESULT = this.range("0", "9");
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.range("A", "F");
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.range("a", "f");
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "hex";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  ws() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "ws") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      RESULT = this.spaces();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.newline();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.lineComment();
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      RESULT = this.delimitedComment();
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "ws";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  spaces() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "spaces") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // REPEAT1
      let ARRAY = [];
      
      while (true) {
        let INITPOS = this.$position;
        
        RESULT = this.char(" \t");
        if (RESULT === FAIL) {
          this.$position = INITPOS;
          break;
        }
        
        ARRAY.push(RESULT);
      }
      
      if (ARRAY.length === 0) RESULT = FAIL;
      else                    RESULT = ARRAY;
      break;
    }
    
    MEMO.rule = "spaces";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  newline() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "newline") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // CHOICE
      let INITPOS = this.$position;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.char("\n");
        if (RESULT === FAIL) break;
        
        while (true) { // OPTIONAL
          let INITPOS = this.$position;
          
          RESULT = this.char("\r");
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            
            RESULT = null;
          }
          
          break;
        }
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      this.$position = INITPOS;
      while (true) { // SEQUENCE
        RESULT = this.char("\r");
        if (RESULT === FAIL) break;
        
        while (true) { // OPTIONAL
          let INITPOS = this.$position;
          
          RESULT = this.char("\n");
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            
            RESULT = null;
          }
          
          break;
        }
        if (RESULT === FAIL) break;
        
        break;
      }
      if (RESULT !== FAIL) break;
      
      break;
    }
    
    MEMO.rule = "newline";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  lineComment() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "lineComment") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.string("--");
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // SEQUENCE
            while (true) { // NEGATE
              let INITPOS = this.$position;
              
              RESULT = this.newline();
              if (RESULT === FAIL) {
                this.$position = INITPOS;
                
                RESULT = null;
                break;
              }
              else {
                RESULT = FAIL;
                break;
              }
            }
            if (RESULT === FAIL) break;
            
            RESULT = this.char();
            if (RESULT === FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.newline();
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "lineComment";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
  delimitedComment() {
    let RESULT = FAIL;
    
    let MEMO = this.$memotab[this.$position];
    if (MEMO.rule === "delimitedComment") {
      this.$position = MEMO.position;
      return MEMO.result;
    }
    
    while (true) { // SEQUENCE
      RESULT = this.string("{#");
      if (RESULT === FAIL) break;
      
      while (true) { // REPEAT
        let ARRAY = [];
        
        while (true) {
          let INITPOS = this.$position;
          
          while (true) { // CHOICE
            let INITPOS = this.$position;
            
            this.$position = INITPOS;
            while (true) { // SEQUENCE
              while (true) { // NEGATE
                let INITPOS = this.$position;
                
                RESULT = this.string("{#");
                if (RESULT === FAIL) {
                  this.$position = INITPOS;
                  
                  RESULT = null;
                  break;
                }
                else {
                  RESULT = FAIL;
                  break;
                }
              }
              if (RESULT === FAIL) break;
              
              while (true) { // NEGATE
                let INITPOS = this.$position;
                
                RESULT = this.string("#}");
                if (RESULT === FAIL) {
                  this.$position = INITPOS;
                  
                  RESULT = null;
                  break;
                }
                else {
                  RESULT = FAIL;
                  break;
                }
              }
              if (RESULT === FAIL) break;
              
              RESULT = this.char();
              if (RESULT === FAIL) break;
              
              break;
            }
            if (RESULT !== FAIL) break;
            
            this.$position = INITPOS;
            RESULT = this.delimitedComment();
            if (RESULT !== FAIL) break;
            
            break;
          }
          if (RESULT === FAIL) {
            this.$position = INITPOS;
            break;
          }
          
          ARRAY.push(RESULT);
        }
        
        RESULT = ARRAY;
        break;
      }
      if (RESULT === FAIL) break;
      
      RESULT = this.string("#}");
      if (RESULT === FAIL) break;
      
      break;
    }
    
    MEMO.rule = "delimitedComment";
    MEMO.position = this.$position;
    MEMO.result = RESULT;
    
    return RESULT;
  }
  
}
