---- Arrays ----

let array_1 <- Array{i64, 6}[0, 1, 2, 3, 4, 5]
let array_2 <- Array{i64, 6}[]


---- Parametric Types ----

Most interesting types are somewhat parametric. Arrays and similar types are 
the most obvious example, but technically so are pointers.

Array{i64, 100}
Array{i64}

addr{i64}


---- Fluorite Runtime System Calling Convention ----

The Fluorite Runtime System has to deal with two basic constraints when dealing
with message sends, and therefore method activation (calls). Those constraints
are C interopability, and effecient language feature implementation.

Interopability with C mostly just requires that we can call C, but the cost
of implementing different strategies for doing so vary significantly. The
strategy considered here is a combined stack strategy, where C and Fluorite
frames are freely intermixed and basic debugging symbols for statically 
compiled code are provided for both allowing basic backtraces and stack
inspection without additional tooling, although such tooling is expected to
allow more comprehensive analysis of Maroon and Fluorite code and data.

Some features of Fluorite prevent the use of the C ABI directly, as it is used
in Objective-C. These features are looked at briefly below, along with the
consiquence to compatability.

Tail messages allow a method to jump to the body of another message without
consuming any additional stack space. This can be extremely efficient for
some algorithms and when done explicitly, as it is in Fluorite, we can avoid
issues like inconsistent stack analysis. To ensure that we can make tail
messages as efficient as possible it is helpful to know exactly how many 
arguments we actually have so that we don't have to spill or fill all of the
registers that are used for parameters. In the AMD64T C ABI used by macOS
there are several general purpose as well as vector float registers used
for parameter passing, which would necessitate a significant amount of 
overhead for such a feature.

Multiary parameters allow an arbitrary number of strictly reference parameters
to be provided to a method. Primitive types must use specialized method
definitions directly, and cannot use generic method handlers, where multiary
parameters are a way to access generic method parameters directly in a flexible
and programatic fashion. These parameters can then be converted into a Vector
or other data structure if required, or could even be peeled of one by one
while checking for the number of arguments actually provided per call.

The issue with multiary parameters is that they must be in an efficient format
since we are likely to use them somewhat more frequently than variadic functions
in C. Making them consistently stack based with a count passed by register, 
would accomplish this in a simple fashion.

The basic strategy appears to be as follows, pass parameters in a parameter
window on the stack. The stack frames are statically sized similarly to C.
The number of actual arguments is passed in a register. Basic data like the
selector information, not just the receiver, should also be passed as parameters
as they are in Objective-C. This will allow calls to perform tail messages 
correctly, as well as evaluate code conditionally on the selector without an
additional calling convention. Call-site metadata is also calculated, but it
is not reused by tail messages or any other messaging mechanism, so it can be
left in registers. There is also the closure parent object, which can just
be passed in a register also, since it is method specific.

There are also some other thread local variables that can be retained in
registers for performance and convenience. The managed frame link can be
computed and left in a register for fast access, for example. The managed
frame link points to the beginning of the Garbage Collector information for 
the frame, and is spilled into a fiber object afterwards. Respectively, the
fiber reference can also be stored in a register for convenience and fast
access. The fiber object also indicates its thread using whatever passes
on the OS in question as a thread id, but that is simply for tools or other
inspectors to interrogate as required.


---- Minimal Object System for Bootstrapping Fluorite ----

class Object () {
  
  static public [...] {                -- va parameters.
    goto allocate.initialize(...);     -- Tail message with original parameters.
  }
  
  static allocate {                    -- Note static is for class methods.
    ...
  }
  
  private public  do @public           -- Abridged notation for method decl.
  private private do @private          -- @private/@public are built in per object.
  private super   do @super            -- @super is also built in for each object.
  
  private initialize do @public        -- By default init returns @public.
  
}

class Vector (Object) {
  
  let count    <- nil;                 -- Variable with id type can be initialized
  let contents <- nil;                 -- using the nil default value.
  let tail     <- array{4}[];          -- Array types are supported over ids.
  
  public count do @count;              -- A simple accessor over instance variable.
  
  public [index] do @tail[index];      -- Remember that arrays are bounds checked.
  
  private initialize(...) {
    if va_count[] > 4 then abort[];    -- va parameters count.
    
    super.initialize                   -- @super provides the super message table.
    
    count <- va_count[];               -- count is actually the accessors for @count.
    for i in va_domain[] {             -- va_domain is interval for va parameters
      @tail[i] <- va[i];
    }
    
    return public;
  }
  
}


---- Object Layout ----

I think that object layout will follow something like the following.

struct Header {
  a: u64; -- class_link:48, tiny?/size:9, gc:7
  b: u64; -- hash:48, hash?:1, reserved:6, slot_count:9
}

struct Object {
  header: Header;
  slots:  array{id,  header.slot_count};
  data:   array{u64, header.size - header.slot_count};
}

The calculations the GC and runtime need to do to bounds check object 
accessing are relatively simple since they're just stored directly in the first
header field. Both the size when accessing bytes, and the slot count when
calculating the data offset or when bounds checking slot accessing are directly
available.

The size is the exact number of word pairs used by the object, which has a 
limit of 256 word pairs in total. This is then bumped by one bit to indicate 
a sign bit, which can tell us whether we are dealing with a tiny object or a 
regular object. The total number of bytes has a 4KB byte limit, and it should
be noted that the size includes the header word pair.

The slot_count is the exact number of slots available, totalling a 512 slot
limit for any single object. This equals the entire 4KB object size limit. Note
that the calculating for the slot_count must take into account that the limit
is not 512, but 510, since two fields are used by the header, and are therefore
reserved and not for actual use.


---- Optimization and Deoptimization ----

Since Fluorite is currently statically compiled, deoptimization is not 
currently planned, or even really possible without a compiler provided by
the runtime system to generate the new code, and a runtime facility to load
it correctly.

The primary optimizations for dynamic languages however, are various kinds of
inline cachine of message lookups, and method inlining. Object transmutation 
should also be discussed.

The former isn't really
affected by anything we're doing and should work more or less unchanged, except
that monomorphic inline caches are not supported since code in Fluorite is
never directly writable, instead polymorphic inline cache tables are used 
instead.

Method inlining is more of a challenge though, since class changes would
require a recompile of any effected methods. This isn't simply a problem for
methods that have yet to be activated, but is also a problem for any stacks
that are currently executing offending out of date methods, that may no longer
reflect object structure or method behavior.

It probably makes sense to limit object structural change completely and limit
method replacement when inlining is turned on in the compiler, allowing 
programs that absolutely must have inlining to perform better, while also
allowing programs that require maximum flexibility to function correctly until
a dynamic optimizing and deoptimizing compiler can be written.

Lastly, object transmutation deserves a minor mention on the topic of inlining.
When a method is inlined, especially accessors, it is likely that another
objects slots or data might be read directly by a method of a different class.
This isn't really a problem directly, but if that object is transmuted, the
slots and data will no longer be tracked by the garbage collector. This
suggests that methods must be inlined between two runtime system 
synchronization points, and never accross a synchronization point.

Synchronization points are a specific kind of concurrency barriers also.


---- Named Literal Objects versus Named Literal Values ----

It occurs to me that I can't really have object literals for true and
false, as well as primitive equivalents. The problem is then, should all constants
in Maroon be capitalized. They probably should anyway, in which case
true and false could simply be consistent with that convention...

nil:   Nil
true:  Boolean
false: Boolean

TRUE:  boolean
FALSE: boolean

NULL:  ptr        -- Assuming that I have this at all...


---- Explicit versus Implicit typing ----

Parameters require explicit types, or must be id references in Fluorite code, 
since they cannot have default values without the default value emitted and
passed by the caller during compilation. Return types are the same as parameters.

Conversely, variables can and must have a default value, even if that value
is just null memory. Null initializers are required for all values and would
simply be emitted by default if the code only specified the type and not the
initializer.

Given this, it makes some sense that variables are initialized and parameters
are type specified.

The only possible exception to this is that this requires that a custom 
allocate method be generated for all concrete classes, since they too would be
initialized to default values, if only null values. They can then be initialized
properly by the objects initialize method afterwards. This is relatively 
important to do in any reasonable managed runtime system to prevent memory
corruption anyway, so either default values may be specified, or the memory
must be cleared to zero.

It may be helpful in some cases for null values that are not cleared memory
to be allowed, in which case real initializers are absolutely required. The 
object initialization strategy is designed to not require this, but it may be
useful when detecting what has or has not been initialized in complex objects.


---- The Object Type vs The id Type ----

It occurs to me that the id type is the general catch all id reference type 
for Fluorite code, similar to Objective-C, and for similar reasons. Like
Objective-C, most code will generally choose to specify Object rather than id
directly, but sometimes there isn't a particular reason to specify any actual
type directly.

The question here is whether we should expect most objects to mixin Object or
not?

If we generally expect all reasonable objects to mixin Object that behave in 
any particularly reasonable fashion, then typing to Object as the basic type
makes sense, similar to most Objective-C or Java programs. On the other hand
some code may have absolutely no interest in what object is present and that
may continue to use id as in Objective-C also.

This suggests that figuring out whether to use id or Object may not always
be completely trivial, but I think that its probably simple enough that it
shouldn't cause any real problems. For the most part, since all instantiable
objects mixin Object anyway, it probably doesn't actually matter.

Even proxy objects or remote objects technically mixin Object, its just done 
in a circuitous fashion. Especially with remote objects, which support all 
of the messages that you would typically expect them to, but obviously cannot
support type messages directly, so the remote object bridge must implement
type compatability to bridge class tags between the two environments in order 
to function correctly.


---- Enumeration in Maroon and Fluorite ----

Enumeration is a slightly tricky concept, most of the time in Fluorite being
done with procs, but sometimes it must be fast or when written in Maroon, must
be implemented using plain data.

To make this work, my current thinking is that something similar to Rust's
traits might work reasonably well, specifically focussing on providing a trait
for a struct that is returned by a enumerate function, or simply by directly
supporting certain built in types directly.

One example of this might be an interval trait, which could support an enumerable
trait, which in turn could suppport the enumerator trait, which then provides
the functions that implement each of the methods like init, condition, iterate.
These functions are obviously just modelled on standard enumeration in C.

Given that this is a fairly straightforward concept, my current thinking is 
that it would be useful to consider providing a interim feature that implements
the common cases directly in the compiler, until traits are implemented. This
interim feature would work on compiler recognized constructs like interval
expressions, and domain primitive calls on arrays or similar.

  for i in [0..9] {...}
  for i in domain[my_array] {...}
  for e in my_array

The latter avoids the issue of not having proper dot operators yet. If I can
get a proper dot operator working then the following would probably also work.

  for i in my_array.domain {...}

The one problem I see immediately is that the above is still just a shorthand
for proper traits, and therefore also for proper enumerators. Some enumerators
therefore cannot be constructed in this way properly. For example, it should be
possible to partially evaluate even some Fluorite code by making standardized
assumptions in the compiler about the implementation of certain types. Intervals
could fit into this and that would allow for more complex intervals to be
constructed.

  for i in [0..9].step(2) {...}

This does not require construction of an Interval instance, but can instead
simply construct an Interval struct. The struct must obviously be named something
other than Interval, but since we're more or less just computing the enumerator
here, we could view this as partially evaluating enumerate, and having it return
a struct, which would then do what we're expecting.

Basically, there would be two enumerate methods, one that returns an appropriate
Enumerator class instance, and one that returns an appropriate Enumerator trait 
instance. Again the names conflict here but we can possibly deal with that by
naming one Iterator or something.

Given all of the above, the implementation would have to either be very specific
to the cases given above, or would probably have to have full support for both
some kind of namespaces to deal with the name collisions as well as some kind
of Rust like trait system. Anything less would likely not fully support all
kinds of basic enumeration behavior, and we would likely still require some
degree of real general use enumeration support anyway.

My current thinking is that we should probably support a conventional for loop
regardless of any of the above, and the benefits that proper enumerators may
bring to the table, simply because they can provide case be case support for
code that has yet to gain an Enumerator/Enumerable trait to support it.


---- Namespaces ----

I'm not yet sure if namespaces are really required for either Maroon or 
Fluorite.

In Fluorite, they don't really make sense since the object capability model is
used to separate modules from one another. All symbols are explicitly pulled
into scope using import statements at the top of a Fluorite module.

In some sense Fluorite modules may require some kind of pattern inclusion of
Maroon/C symbols to allow things like OpenGL or SDL to be quickly and
effectively pulled into scope. This would then allow those functions or types
to be referred to relatively straightforwardly, but as a rule arbitrary use
of global names would interfere with local messages, since only names that
are not in lexical scope are sent to the local private interface.

A more general prefix could be used to allow accessing the complete Maroon/C
namespace when it is required. Something like mn.glVertex3f or something.

In Maroon on the other hand, the design I'm currently considering is to use
some combination of C compatability, which will make the bridge with Fluorite
a little simpler also, combined with features like Rust's traits to facilitate
type parametricity and generic functions.

On a minor side note, I wonder if the type parametricity can be unified between
the gradual typing in Fluorite and the strictly compile time strategy required
for a Rust style trait system.

  
---- macOS x86-64 Calling Convention Notes ----

  * rdx:rax is return value.
  * rdi, rsi, rdx, rcx, r8, r9 are integer parameters.
  * rbx, rsp, rbp, r12, r13, r14, r15 are preserved.
  * r10 is the static chain pointer, not used by C programs (i.e., scratch).
  * r11 is scratch.
  
  * zmm0-zmm7 are FP parameters.
  * zmm8-zmm31 are FIXME[scratch|preserved].
  * k0-k7 are FIXME[scratch|preserved].
  
  * DF in %rFLAGS must be clear on function entry and exit (direction flag should be set to forward).
  * x87 (not MMX) mode should be set on function entry and exit.
  * x87 registers are scratch and MMX cannot be set, use `femms` to switch to x87 before exit if necessary.
  * MXCSR and x87 control bits are preserved.
  * MXCSR and x87 status bits are scratch.
  
  * Stack alignment must at least 16 bytes.
  * When a 32 byte parameter is passed call stack alignment must be at least 32 bytes.
  * When a 64 byte parameter is passed call stack alignment must be at least 64 bytes.
  
  * rbp where used should point directly to preserved rbp location.
  * preserved rbp should be immediately below the return address.
  * rsp should point to the first stack location in the current frame.
  * -128(%rsp) is the 'red zone' and may be used by leaf functions instead of a proper frame.
  * al (not zero/sign extended) for vararg calls must be upper bound on SSE parameters.
  
  * _Bool, boot_t and bool (C++) are either 1 byte values 0x01 or 0x00.
  
  * Types that are smaller than an 8 byte integer are not zero/sign extended.
  
  * _Bool, bool_t and bool (C++) are passed as 8 byte integer.
  * char, short, int, long, long long and pointers are passed as 8 byte integer.
  * float, double, _Decimal32 and _Decimal64 are passed as 8 byte SSE.
  * __int128 are passed as two __int64 struct except with 16 byte alignment when passed on stack.
  
  * structs larger than 16 bytes are passed on the stack
  * small structs are passed as 8 byte chunks.
  * if a chunk contains any integers it is passed in an alu register.
  * if a chunk only contains floats or doubles it is passed in SSE.
  * two floats may need to be packed into a single SSE register.
  * multiple integers and possibly a float may need to be packed into a single ALU register.


---- Note on macOS Executable Format ----

macOS uses a small executable memory layout (object) model, and doesn't require
complex handling of offset tables in current x86-64 systems, but there are
potentially some cases which might require the use of `name@GOTPCREL(%rip)`
style indirect accesses of data, where the data is considered too large to
be put into the 2GB region of an executable, and is instead put in the larger
4GB region from beginning from the GOT.

These large addresses require a proper offsets and thus all code and small 
data are stored within Â±2GB of the GOT, and large objects may be 2-4GB after
the GOT which will still be within the 4GB size limit imposed by the macOS ABI 
on executable/library memory layouts.

Also, any data element that is not defined in the current executable must be
accessed through `callq name` or `movq name@GOTPCREL(%rip), %rax; 
movq (%rax), %rax`. The former will in cases where the name is not local to 
the linked file, automatically generate a very near call into a trampoline at 
the end of the current procedure, responsible for loading the correct address 
and branching to it. Basically, both methods are effectively the same, more 
or less.


---- Order Operations in Assembly ----

In the current code configuration, I don't have any way to generate single
byte instruction operands only eight byte instruction operands. Because of
this it was easier to simply not support ordering operators.

It should be possible to implement an ordering operator similar to the
following at a assembly level:

ord_i64(rdi, rsi)  ## Parameters rdi, rsi; returning rax; scratching rdx.
  cmpq   rdi, rsi  ## These could possibly be in same registers?
  setl   al
  setg   dl
  subb   al, dl
  movzbq rax, al

The following table indicates the correlation between flags and ordering.

              Result  Less  Greater  Below  Above  Equal
Ascending          1     1        0      1      0      0
Equal              0     0        0      0      0      1
Descending        -1     0        1      0      1      0
