
{ tag: "AddrExpression",
  location:
    { tag: "LookupLocation", 
      name: "my_variable",
      declaration:
        { tag: "Variable", 
          name: "my_variable",
          kind: "LocalVariable",
          loffset: 8 } } }

ASM:
  leaq  -8(%rbp), %rbx      -- LookupLocation codegen
  movq  %rbx, -16(%rbp)     -- AddrExpression return result to stack


{ tag: "LoadExpression",
  location:
    { tag: "LookupLocation", 
      name: "my_variable",
      declaration:
        { tag: "Variable", 
          name: "my_variable",
          kind: "LocalVariable",
          loffset: 8 } } }

ASM:
  leaq  -8(%rbp), %rbx      -- LookupLocation codegen
  movq  (%rbx), %rax        -- LoadExpression load variable
  movq  %rax, -16(%rbp)     -- LoadExpression return result to stack


{ tag: "StoreExpression",
  location:
    { tag: "LookupLocation", 
      name: "my_variable",
      declaration:
        { tag: "Variable", 
          name: "my_variable",
          kind: "LocalVariable",
          loffset: 8 } } 
  value:
    { tag: "IntegerLiteral",
      value: 42,
      ... } }

ASM:
  leaq  -8(%rbp), %rbx      -- LookupLocation codegen
  movq  $42, %rax           -- IntegerLiteral codegen
  movq  %rax, -16(%rbp)     -- IntegerLiteral temporary result to stack
  movq  -16(%rbp), %rax     -- StoreExpression load value
  movq  %rax, (%rbx)        -- StoreExpression store value
                            -- Leave loaded value intact on stack as result


{ tag: "StoreExpression",
  location:
    { tag: "FieldLocation", 
      subject:
        { tag: "SymbolLocation",
          name: "my_struct", 
          declaration:
            { tag: "Variable",
              name: "my_struct",
              kind: "LocalVariable",
              loffset: 8 } },
      name: "field_a" },
  value:
    { tag: "IntegerLiteral",
      value: 42,
      ... } }

ASM:
  leaq  -8(%rbp), %rbx     -- SymbolLocation  my_struct.addr
  addq  0, %rbx            -- FieldLocation   my_struct.field_a.addr
  movq  $42, %rax          -- IntegerLiteral  42
  movq  %rax, -16(%rbp)    -- IntegerLiteral  *store-result*
  movq  -16(%rbp), %rax    -- StoreExpression *load-value*
  movq  %rax, (%rbx)       -- StoreExpression *store-value-into-location*
                           -- StoreExpression *leave-value-on-stack*


struct Vec2 {
  i64 x;
  i64 y;
}

let a <- Vec2[x: 0, y: 0];
let b <- Vec2[x: 1, y: 1];

let c <- Vec2 { x: a.x + b.x, y: a.y + b.y };

let ax <- addr[a.x]
let bx <- addr[b.x]

let cx <- addr[c.x]

ref[cx] <- ref[ax] + ref[bx]





a             <- 0
ref[a]        <- 0

ref[ref[a]]   <- 0

a.b           <- 0
ref[a.b]      <- 0

a.b.c         <- 0

ref[a].b      <- 0
ref[ref[a].b] <- 0



struct Vec2 {
  x: i64;
  y: i64;
}

let point_1 <- Vec2[x: 0, y: 2]; -- You can specify all or some of the fields.
let point_2 <- Vec2[0, 2];       -- You can specify all fields in order.
let point_3 <- Vec2[];           -- Or simply let them initialize to zero.
                                 -- In theory we could optimize if we know the 
                                 -- fields are about to be initialized later.

I think that the padding should also be initialized to zero for consistency.
This could be achieved by putting two writes in, or simply zero extending fields
as required, to some larger data width. Perhaps I can put an extend field in when
calculating struct layout.

Any bytes after the end of the struct can probably be left alone since I would
assume that the user is not going to be copying past the end, unless they intend
to add padding themselves. This might occur when copying data directly to a file
or mapped file.

If they are writing to a buffer or other memory that includes padding after the
structure, it would make sense to allow the creation of a compatible, but padded,
structure type, which could then be allocated.

The consiquence of such a feature is that the code remains a procedure until
after type analysis, since type analysis is required to calculate the synthesized
padded structure type and type check the function call and assign typing.

Only after this typing is complete can the compiler rewrite the assignment to an
initialization. This is similar to the analysis of a function that returns a 
structure ref, or a referenced pointer, which also needs to be rewritten to a
copy struct operation.

Perhaps I could also simply add support for all three cases in the same branch
of the codegen even, since they're completely type and concept compatible, 
merely different in code output.

let array_1 <- Array{i64, 6}[0, 1, 2, 3, 4, 5]
let array_2 <- Array{i64, 6}[]




