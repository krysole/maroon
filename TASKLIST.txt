TASKLIST

- Implement DWARF information that is more or less C compatible and can be used
	by LLDB to effectively debug a Maroon program. This will likely be required
	for some bugs before a Fluorite compatible debugger is written so I might
	as well just implement it sooner rather than later.
	This will also allow me to avoid having to necessarily dip into C to write
	the runtime for Fluorite, allowing me to more fully test out the systems 
	language and compiler.
	
- First, I need to get a lexer that can handle the source code properly.
- Secondly, get the parser reading tokens rather than raw text, although I don't
	intend to change the output right away.
- Third, since I'm at it anyway, I might as well implement the layout rules.
- Fouth, start propagating tokens into the ast as source information from the parser.
- Fifth, rework the simplifier and type analysis to propagate source information
	during any rewriting.
- Sixth, source information in hand, generate the DWARF for functions.
- Seventh, generate DWARF for line versus instructions.
- Eighth, generate and test DWARF/CFI for function backtraces in lldb and
	line by line debugging, et cetera.
- Ninth, generate and test DWARF for global variables.
- Tenth, generate and test DWARF for local variables.
- Eleventh, generate DWARF for struct definitions.


- Initialization of array null initialization should be based on a proper loop and
	not an unrolled loop. Otherwise large arrays would be uninitializable for the
	most part (without excessive codegen).
- Initialization of global array with null initialization should probably allow
	for zero cleared initialization as required.
- There should be a zero fill initialization for array globals, for fast allocation
	of very large arrays without taking up executable space.
- There should be a zero fill initialization for array locals that mirrors zero
	initialization for globals, for consistency.

- Implement bounds checking for array subscripting, since we know the bounds of
	arrays directly. Obviously if the index is known to be within bounds then we
	shouldn't generate a bounds check, so some direction should be possible during
	analysis or via an annotation.

- Implement automatic synthesis of provided methods like allocate for concrete
	classes, or the class tag behaviors.
- Implement code generation for Fluorite methods. This will require some changes
	to frame layout, to support the GC frame link and GC id count. Perhaps a 
	separate frame layout style would make sense, one that isn't based on fixed
	frame size, but instead does allow for the stack to grow and shrink.
- Implement fluorite_class_data generation for classes.
- Update method code generation to at least ensure that the managed references
	are stored in the stack frame separately from other stack frame data, and that
	they are at the beginning of the frame, along with a 32 bit count field and 
	managed frame link field as an offset rather than a pointer.
- Implement va varargs primitive functions for methods.

- Continue analyzing the design and tasks for The Fluorite Programming Language.
- Consider changing IntegerLiteral et cetera, into IntegerExpression et cetera.

- Consider turning memoization back on in the parser, since it should still work.
	This would help with the performance of branches with common left factors.
